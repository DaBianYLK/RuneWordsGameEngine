/*--------------------------------------------------------------------------------------------------------------------*\
   【CREATE】	
	AUTH :	大便一箩筐																			   DATE : 2016-04-14
	DESC :	RWGE游戏引擎架构设计思路与笔记
	目录 ：	
	1.	RAII和二段构造模式的取舍																   DATE : 2016-04-14
	2.	单D3D Device与多D3D Device的取舍														   DATE : 2016-04-20
\*--------------------------------------------------------------------------------------------------------------------*/

1.	RAII和二段构造模式的取舍
	RAII（Resource Acquisition is Initialization，资源的获取就是初始化）是C++ 标准委员会明确提出的一个C++ 设计原则：
	对象所有的初始化工作都在构造函数中完成，所有释放工作都在析构函数中完成。

	二段构造模式则是一个历史遗留产物：如果C++ 在执行对象的构造函数时发生异常，会析构已经初始化的成员变量并释放内存。
	如果此时成员变量中存在指针，便会发生内存泄漏，同时析构函数也无法执行。因此，为了获取对象初始化是否成功，同时避免
	“构造函数执行失败时无法回滚”，开发者将对象初始化工作从构造函数中分离出来，放在Create或Init函数中执行，同时定义
	Destory 或Release 函数，用于初始化失败时释放资源。

	二段构造带来的副作用显而易见：一个对象的生命周期的状态由“存在、不存在”变为了“存在、有效、无效、不存在”，直接
	导致使用对象的过程变得繁琐，还埋下了容易发生内存泄漏的潜在隐患。而在C++ 支持智能指针之后，二段构造的优势也荡然无
	存：通过智能指针，一旦构造函数执行失败，智能指针会便会调用所指对象的析构函数，从而达到资源释放的目的。
	
	相比之下，RAII在易用性和安全性上都更胜一筹：对象只要存在，就一定可用；一旦对象离开作用域，就会自动执行析构函数，
	避免了开发者手动释放资源。

	综上所述，在使用C++ 开发的过程中，应该遵循RAII原则，尽量避免使用二段构造。

	Ps：目前比较典型，仍然使用二段构造的两个例子是微软的MFC 和触控科技的Cocos2d-x ，然而MFC 完全是因为上面提到的历史
	原因才使用了二段构造，现在为了兼容性无法修改。而Cocos2d-x 为了兼容Objective-C， 不得不使用二段构造：OC中压根就没
	有构造函数的概念；同时Cocos2d-x 也不提倡分离构造函数和初始化函数，它为每个类都定义了一个静态Create方法，用于封装
	构造函数和初始化函数，避免二段构造带来的问题。								  

2.	单D3D Device与多D3D Device的取舍
	通过支持多Device可以实现多窗口渲染，但通过SwapChain 可以实现同样的效果，因此多D3D Device并没有特别明显的优势。与
	此同时，使用多个Device却带来了很多弊端：可能导致Texture、 Shader等资源的浪费，同时也会导致引擎的架构变得复杂，降
	低引擎的运行效率，因此放弃对多Device的支持是一个更好的选择。